
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
        <title>Tree</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/orbitControls.js"></script>
        <script>
            // Our Javascript will go here.

            function lengthChooser(min, max) {
              return function() { return Math.random()*(max - min) + min; };
            }

            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );

            var min = 2, max = 6;
            var minRadius = 0.3;

            var lengthFunction = lengthChooser(min, max);
            var colorList = [
              "#00441b",
              "#006d2c",
              "#238b45",
              "#41ab5d",
              "#74c476",
              "#a1d99b",
              "#c7e9c0",
              "#e5f5e0"
            ];

            var materials = colorList.map(function(col) {
              return new THREE.MeshPhongMaterial( {color: col});
            });


            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );

            var controls = new THREE.OrbitControls( camera, renderer.domElement );

            document.body.appendChild( renderer.domElement );

            var ambientLight = new THREE.AmbientLight(0xffffff);

            var size = 10;
            var step = 1;

            var gridHelper = new THREE.GridHelper( size, step );
            scene.add( gridHelper );

            scene.add( ambientLight );

            camera.position.z = 50;
            camera.position.y = 80;
            // camera.lookAt(new THREE.Vector3(0, 150, 0 ))

            function render() {
                requestAnimationFrame( render );
                renderer.render( scene, camera );

                controls.update();
            }

            var treeData = [{
                radius: 6,
                sizeReduction: .85,
                branchProbability: 0.12,
                position: new THREE.Vector3(0, 0, 0),
                rotation: new THREE.Vector3(0, 1, 0)
            }, {
                radius: 3,
                sizeReduction: .87,
                branchProbability: 0.25,
                position: new THREE.Vector3(10, 0, -10),
                rotation: new THREE.Vector3(0,  1,  0)
            }, {
                radius: 7,
                sizeReduction: .82,
                branchProbability: 0.22,
                position: new THREE.Vector3(10, 0, 10),
                rotation: new THREE.Vector3(0,  1,  0)
            }];

            function createSegment(treeSegment) {

              if (treeSegment.radius < minRadius) {
                return;
              }

              var localPosition = new THREE.Vector3();
              localPosition.copy(treeSegment.position);
              var localRotation = new THREE.Vector3();
              localRotation.copy(treeSegment.rotation);

              var materialIndex = Math.floor(treeSegment.radius);
              var material = materials[materialIndex];
              var topRadius = treeSegment.radius * treeSegment.sizeReduction;
              console.log("radius old, new", treeSegment.radius, topRadius);
              var length = lengthFunction();

              var geometry = new THREE.CylinderGeometry(
                topRadius,
                treeSegment.radius,
                length,
                10
              );

              var cylinder = new THREE.Mesh(geometry, material);
              cylinder.position.x = localPosition.x;
              cylinder.position.y = localPosition.y;
              cylinder.position.z = localPosition.z;

              cylinder.rotation.x = treeSegment.rotation.x;
              cylinder.rotation.y = treeSegment.rotation.y;
              cylinder.rotation.z = treeSegment.rotation.z;

              scene.add(cylinder);

              var newRecursiveSegment = Object.assign({}, treeSegment);
              newRecursiveSegment.radius = topRadius;
              newRecursiveSegment.position = localPosition;
              newRecursiveSegment.rotation = localRotation;

              var updateVector = new THREE.Vector3(0,1,0);
              var rotationMatrix = new THREE.Matrix4();
              var euler = new THREE.Euler();
              euler.setFromVector3(newRecursiveSegment.rotation, 'XYZ');
              rotationMatrix.makeRotationFromEuler(euler);
              updateVector.transformDirection(rotationMatrix);
              updateVector.multiplyScalar(length);

              newRecursiveSegment.position.add(updateVector);
              console.log("newrec pos", newRecursiveSegment.position);

              createSegment(newRecursiveSegment);

              if (Math.random() < newRecursiveSegment.branchProbability) {

                var newBranchSegment = Object.assign({}, treeSegment);
                newBranchSegment.position = localPosition;
                newBranchSegment.rotation = localRotation;
                newBranchSegment.rotation.x += Math.random() - 0.5;
                newBranchSegment.rotation.y += Math.random() - 0.5;
                newBranchSegment.rotation.z += Math.random() - 0.5;
                newBranchSegment.rotation.normalize();
                // TODO: update position due to rotation effects here?
                createSegment(newBranchSegment);
              }
            }

            function renderTree(singleTree){
                createSegment(singleTree)
            }

            treeData.forEach(function(t){ renderTree(t); });

            render();
        </script>
    </body>
</html>
