
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
        <title>Tree</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/orbitControls.js"></script>
        <script>
            // Our Javascript will go here.

            function lengthChooser(min, max) {
              return function() { return Math.random()*(max - min) + min; };
            }

            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );

            var min = 4, max = 6;

            var lengthFunction = lengthChooser(min, max);

            var materials = [
              new THREE.MeshPhongMaterial( { color: "#feb24c"}),
              new THREE.MeshPhongMaterial( { color: "#fd8d3c"}),
              new THREE.MeshPhongMaterial( { color: "#fc4e2a"}),
              new THREE.MeshPhongMaterial( { color: "#e31a1c"}),
              new THREE.MeshPhongMaterial( { color: "#bd0026"}),
              new THREE.MeshPhongMaterial( { color: "#800026"})
            ];

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );

            var controls = new THREE.OrbitControls( camera, renderer.domElement );

            document.body.appendChild( renderer.domElement );

            var ambientLight = new THREE.AmbientLight(0xffffff);

            var size = 10;
            var step = 1;

            var gridHelper = new THREE.GridHelper( size, step );
            scene.add( gridHelper );

            scene.add( ambientLight );

            camera.position.z = 50;
            camera.position.y = 80;
            // camera.lookAt(new THREE.Vector3(0, 150, 0 ))

            function render() {
                requestAnimationFrame( render );
                renderer.render( scene, camera );

                controls.update();
            }

            var treeData = [{
                radius: 5,
                sizeReduction: .9,
                branchProbability: 0.1,
                position: new THREE.Vector3(0,0,0),
                rotation: new THREE.Vector3(0, 1, 0)
            }, {
                radius: 3,
                sizeReduction: .7,
                branchProbability: 0.2,
                position: new THREE.Vector3(10, 0, -10),
                rotation: new THREE.Vector3(0,  1,  0)
            }];

            function createSegment(treeSegment) {

              console.log("should I add this? radius: ", treeSegment.radius);
              if (treeSegment.radius < 0.2) {
                return;
              }

              var localPosition = new THREE.Vector3();
              localPosition.copy(treeSegment.position);
              var localRotation = new THREE.Vector3();
              localRotation.copy(treeSegment.rotation);

              var materialIndex = Math.floor(treeSegment.radius);
              var material = materials[materialIndex];
              var topRadius = treeSegment.radius * treeSegment.sizeReduction;
              var length = lengthFunction();
              var newRecursiveSegment = Object.assign({}, treeSegment);
              newRecursiveSegment.position = localPosition;
              newRecursiveSegment.rotation = localRotation;

              var geometry = new THREE.CylinderGeometry(
                topRadius,
                treeSegment.radius,
                length,
                10
              );

              var cylinder = new THREE.Mesh(geometry, material);
              cylinder.position.x = treeSegment.position.x;
              cylinder.position.y = treeSegment.position.y;
              cylinder.position.z = treeSegment.position.z;

              cylinder.rotation.x = treeSegment.rotation.x;
              cylinder.rotation.y = treeSegment.rotation.y;
              cylinder.rotation.z = treeSegment.rotation.z;

              console.log("adding with rotation", treeSegment.rotation.x, treeSegment.rotation.y);
              scene.add(cylinder);

              newRecursiveSegment.radius = topRadius;

              console.log("current y", newRecursiveSegment.position.y);
              console.log("current x", newRecursiveSegment.position.x);

              var updateVector = new THREE.Vector3(0,1,0);
              var rotationMatrix = new THREE.Matrix4();
              var euler = new THREE.Euler();
              euler.setFromVector3(newRecursiveSegment.rotation, 'XYZ');
              rotationMatrix.makeRotationFromEuler(euler);
              updateVector.transformDirection(rotationMatrix);

              newRecursiveSegment.position.add(updateVector);
              console.log("new y", newRecursiveSegment.position.y, "length", length);

              createSegment(newRecursiveSegment);

              if (Math.random() < newRecursiveSegment.branchProbability) {
                console.log("WE GOT A BRANCH OMG");

                var newBranchSegment = Object.assign({}, treeSegment);
                newBranchSegment.position = localPosition;
                newBranchSegment.rotation = localRotation;
                newBranchSegment.rotation.x += Math.random();
                newBranchSegment.rotation.normalize();
                createSegment(newBranchSegment);
              }
            }

            function renderTree(singleTree){
                createSegment(singleTree)
            }

            treeData.forEach(function(t){ renderTree(t); });

            render();
        </script>
    </body>
</html>
