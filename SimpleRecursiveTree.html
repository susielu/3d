
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
        <title>Tree</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/orbitControls.js"></script>
        <script>
            'use strict';

            const lengthChooser = (min, max) => () => Math.random()*(max - min) + min;

            var scene = new THREE.Scene();
            // scene.fog = new THREE.Fog( "#cce0ff", 500, 10000 );

            var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.z = 250;
            camera.position.y = 40;

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMap.enabled = true;
            renderer.shadowMapType = THREE.PCFSoftShadowMap;
            // renderer.gammaInput = true;
            // renderer.gammaOutput = true;
            // renderer.antialias = true;

            document.body.appendChild( renderer.domElement );

            var controls = new THREE.OrbitControls( camera, renderer.domElement );
            // changes focal point of camera
            controls.target = new THREE.Vector3( 0, 80, 0 )


            // var gridHelper = new THREE.GridHelper( 200, 10 ); //size and step
            // scene.add( gridHelper );

            var ground = new THREE.PlaneBufferGeometry( 2000, 2000 );
            // var groundMaterial = new THREE.MeshBasicMaterial( {color: "#42e873", side: THREE.DoubleSide} );

            var groundMaterial = new THREE.MeshStandardMaterial( {
                  color: "#07b63a",
                  emissive: "#343991",
                  roughness: 1,
                  metalness: 0,
                  emissiveIntensity: 1
                })
            var plane = new THREE.Mesh( ground, groundMaterial );

            // plane.position.y = - 250;
            plane.rotation.x = - Math.PI / 2;
            plane.receiveShadow = true;
            scene.add( plane );


            // Lights
            // var lights = [];
            // lights[ 0 ] = new THREE.PointLight( "#fff", 1, 0 );
            // lights[ 1 ] = new THREE.PointLight( "#fff", 1, 0 );
            // lights[ 2 ] = new THREE.PointLight( "#fff", 1, 0 );

            // lights[ 0 ].position.set( 0, 300, 0 );
            // lights[ 1 ].position.set( 300, 300, 200 );
            // lights[ 2 ].position.set( -200, -500, -200 );

            // lights.map(l => {
            //   l.castShadow = true;
            //   // l.shadowDarkness = .5;
            //   return l
            // })

            // // scene.add( lights[ 0 ] );
            // scene.add( lights[ 1 ] );
            // //scene.add( lights[ 2 ] );

            var light = new THREE.DirectionalLight("#4444cc", 1)
              light.position.set( 100, 100, 1 ).normalize();

              scene.add( light );
            // var spt = new THREE.SpotLight(0xFFFFFF);
            var spt = new THREE.SpotLight("#fff9b5");

            spt.position.set(200, 200, 40);
            spt.castShadow = true;
            spt.angle = 0.75;
            spt.exponent = 10.0;
            spt.penumbra = 0.1;
            spt.decay = 1;
            spt.distance = 1000;
            spt.shadow.mapSize.width = 1024;
            spt.shadow.mapSize.height = 1024;
            // shadow camera helper
            spt.shadowCameraHelper = new THREE.CameraHelper( spt.shadow.camera ); // colored lines
            spt.shadow.camera.near = 0.1;
            spt.shadow.camera.far = 20000;

            // var spotLight = new THREE.SpotLight( "white", 10, 100 );

            // spotLight.position.set( 100, 1000, 100 );

            // spotLight.castShadow = true;

            // spotLight.shadow.mapSize.width = 1024;
            // spotLight.shadow.mapSize.height = 1024;

            // spotLight.shadow.camera.near = 500;
            // spotLight.shadow.camera.far = 4000;
            // spotLight.shadow.camera.fov = 30;
            //  // spotLight.target.position.set( 100, 100, 1 );
            //   // spotLight.shadowCameraNear  = 0.01;
            //   // spotLight.castShadow    = true;

            //   // spotLight.shadowDarkness  = 0.5;
            //   // spotLight.shadowCameraVisible = true;

            scene.add( spt );

            //Colors
            var colorList = {
              blue: [{ color: "#07b63a", emissive: "#343991"},
                  { color: "#42e873", emissive: "#543491"},
                  { color: "#42e873", emissive: "#543491"},
                  { color: "#3cc8c8", emissive: "#553491"},
                  { color: "#3cc8c8", emissive: "#553491"},
                  { color: "#3cc8c8", emissive: "#553491"},
                  { color: "#3cc8c8", emissive: "#361572"},
                  { color: "#3cc8c8", emissive: "#361572"},
                  { color: "#3cc8c8", emissive: "#361572"}
                ],
              pink: [
                { color: "#f55151", emissive: "#343991"},
                { color: "#f551d7", emissive: "#5988fc"},
                { color: "#7f2f71", emissive: "#5962fc"},
                { color: "#500d44", emissive: "#5962fc"},
                { color: "#500d44", emissive: "#5962fc"},
                { color: "#500d44", emissive: "#3f44a2"},
                { color: "#500d44", emissive: "#232778"},
                { color: "#500d44", emissive: "#232778"},
                { color: "#500d44", emissive: "#227878"}
              ]
            }

            var materials = colorList;
            Object.keys(colorList).forEach(function(key) {

              materials[key] = materials[key].map(function(c){

                return new THREE.MeshStandardMaterial( {
                  color: c.color,
                  emissive: c.emissive,
                  roughness: 1,
                  metalness: 0,
                  emissiveIntensity: 1
                });
              });
            });


            var MIN = 2, MAX = 6;
            var minRadius = 0.3;

            var lengthFunction = lengthChooser(MIN, MAX);

            function render() {
                requestAnimationFrame( render );
                renderer.render( scene, camera );
                controls.update();
            }

            var treeData = [{
                radius: 6,
                sizeReduction: .85,
                branchProbability: 0.12,
                position: new THREE.Vector3(0, 0, 0),
                rotation: new THREE.Vector3(0, 1, 0),
                color: 'blue'
            }, {
                radius: 3,
                sizeReduction: .87,
                branchProbability: 0.25,
                position: new THREE.Vector3(10, 0, -10),
                rotation: new THREE.Vector3(0,  1,  0),
                color: 'blue'
            }, {
                radius: 7,
                sizeReduction: .82,
                branchProbability: 0.22,
                position: new THREE.Vector3(20, 0, 10),
                rotation: new THREE.Vector3(0,  1,  0),
                color: 'blue'
            },{
                radius: 7,
                sizeReduction: .82,
                branchProbability: 0.22,
                position: new THREE.Vector3(-20, 0, 5),
                rotation: new THREE.Vector3(0,  1,  0),
                color: 'blue'
            },{
                radius: 7,
                sizeReduction: .82,
                branchProbability: 0.22,
                position: new THREE.Vector3(-20, 0, -25),
                rotation: new THREE.Vector3(0,  1,  0),
                color: 'blue'
            },{
                radius: 7,
                sizeReduction: .92,
                branchProbability: 0.1,
                position: new THREE.Vector3(-15, 0, 15),
                rotation: new THREE.Vector3(0,  1,  0),
                color: 'pink'
            },{
                radius: 10,
                sizeReduction: .75,
                branchProbability: 0.28,
                position: new THREE.Vector3(-20, 0, -15),
                rotation: new THREE.Vector3(0,  1,  0),
                color: 'pink'
            }];

            function createSegment(treeSegment) {

              if (treeSegment.radius < minRadius) {
                return;
              }

              var localPosition = new THREE.Vector3();
              localPosition.copy(treeSegment.position);
              var localRotation = new THREE.Vector3();
              localRotation.copy(treeSegment.rotation);

              var materialIndex = Math.min(Math.floor(treeSegment.radius), materials[treeSegment.color].length - 1 );
              var material = materials[treeSegment.color][materialIndex];
              var topRadius = treeSegment.radius * treeSegment.sizeReduction;
              // console.log("radius old, new", treeSegment.radius, topRadius);
              var length = lengthFunction();

              var geometry = new THREE.CylinderGeometry(
                topRadius,
                treeSegment.radius,
                length,
                10
              );

              var cylinder = new THREE.Mesh(geometry, material);
              cylinder.position.x = localPosition.x;
              cylinder.position.y = localPosition.y;
              cylinder.position.z = localPosition.z;

              cylinder.rotation.x = treeSegment.rotation.x;
              cylinder.rotation.y = treeSegment.rotation.y;
              cylinder.rotation.z = treeSegment.rotation.z;
              cylinder.castShadow = true;
              cylinder.receiveShadow = true;

              scene.add(cylinder);

              var newRecursiveSegment = Object.assign({}, treeSegment);
              newRecursiveSegment.radius = topRadius;
              newRecursiveSegment.position = localPosition;
              newRecursiveSegment.rotation = localRotation;

              var updateVector = new THREE.Vector3(0,1,0);
              var rotationMatrix = new THREE.Matrix4();
              var euler = new THREE.Euler();
              euler.setFromVector3(newRecursiveSegment.rotation, 'XYZ');
              rotationMatrix.makeRotationFromEuler(euler);
              updateVector.transformDirection(rotationMatrix);
              updateVector.multiplyScalar(length);

              newRecursiveSegment.position.add(updateVector);
              // console.log("newrec pos", newRecursiveSegment.position);

              createSegment(newRecursiveSegment);

              if (Math.random() < newRecursiveSegment.branchProbability) {

                var newBranchSegment = Object.assign({}, treeSegment);
                newBranchSegment.position = localPosition;
                newBranchSegment.rotation = localRotation;
                newBranchSegment.rotation.x += Math.random() - 0.5;
                newBranchSegment.rotation.y += Math.random() - 0.5;
                newBranchSegment.rotation.z += Math.random() - 0.5;
                newBranchSegment.rotation.normalize();
                // TODO: update position due to rotation effects here?
                createSegment(newBranchSegment);
              }
            }

            function renderTree(singleTree){
                createSegment(singleTree)
            }

            window.addEventListener( 'resize', function () {

              camera.aspect = window.innerWidth / window.innerHeight;
              camera.updateProjectionMatrix();

              renderer.setSize( window.innerWidth, window.innerHeight );

            }, false );

            //Create all of the trees initially
            treeData.forEach(function(t){ renderTree(t); });

            render();
        </script>
    </body>
</html>
